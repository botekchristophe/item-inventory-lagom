package ca.cbotek.item.impl.readside

import akka.Done
import ca.cbotek.item.api.CartItem
import ca.cbotek.item.impl.event.{CartCheckedout, CartCreated, CartEvent, CartItemsUpdated}
import ca.cbotek.item.impl.model.CartStatuses
import com.datastax.driver.core.{BoundStatement, PreparedStatement}
import com.lightbend.lagom.scaladsl.persistence.ReadSideProcessor.ReadSideHandler
import com.lightbend.lagom.scaladsl.persistence.cassandra.{CassandraReadSide, CassandraSession}
import com.lightbend.lagom.scaladsl.persistence.{AggregateEventTag, EventStreamElement, ReadSideProcessor}
import org.slf4j.LoggerFactory
import play.api.libs.json.Format

import scala.concurrent.{ExecutionContext, Future}

/**
  * A Cart read side processor is in charge of listening to the internal event stream and to update a read side database
  * on some events. This processor is reacting on [[CartEvent]].
  *
  * Events are processed once and only once in an eventual consistency fashion. The readSide generated by this processor
  * will eventually have all the information with some delay.
  *
  * @see com.lightbend.lagom.scaladsl.persistence.ReadSideProcessor
  *
  * @param readSide a Cassandra read side builder provided by Lagom persistence module.
  * @param session a Cassandra session which will be used to prepare some CQL statements.
  * @param ec a execution context requested implicitly by the use of [[Future]]
  */
class CartReadSideProcessor(readSide: CassandraReadSide, session: CassandraSession)
                           (implicit ec: ExecutionContext) extends ReadSideProcessor[CartEvent] {

  private val log = LoggerFactory.getLogger(classOf[CartReadSideProcessor])

  /**
    * An insert statement for new Carts
    */
  private var insertCartStatement: PreparedStatement = _

  /**
    * An update statement used to update cart items
    */
  private var updateCartItemsStatement: PreparedStatement = _

  /**
    * An update statement used to update cart status and checkout price
    */
  private var updateCartCheckoutStatement: PreparedStatement = _

  def buildHandler: ReadSideHandler[CartEvent] = {
    readSide
      .builder[CartEvent]("cartOffset")
      .setGlobalPrepare(createTable)
      .setPrepare { _ => prepareStatements()}
      .setEventHandler[CartCreated](cartCreated)
      .setEventHandler[CartItemsUpdated](cartItemsUpdated)
      .setEventHandler[CartCheckedout](cartCheckedOut)
      .build()
  }

  /**
    * This method is executed a the very beginning of the instantiation of the read side processor.
    *
    * @return a Future [[Done]] once the statement is executed
    */
  private def createTable(): Future[Done] = {
    for {
      _ <- session.executeCreateTable(
        """
          |CREATE TABLE IF NOT EXISTS carts (
          |   id uuid, user text, items text, status text, checkout_price text,
          |   PRIMARY KEY (id)
          |   )
        """.stripMargin)
    } yield Done
  }

  /**
    * Method used to prepare all statements used by the read side processor.
    * Here we have 3 statement that correspond to the 3 variable created on top of the class.
    *
    * @return returns a Future Done once all statements are prepared.
    */
  private def prepareStatements(): Future[Done] = {
    for {
      insertCart <- session.prepare(
        """
          |INSERT INTO carts
          |(id, user, items, status)
          |VALUES (?, ?, ?, ?)
        """.stripMargin
      )

      updateCartItems <- session.prepare(
        """
          |UPDATE carts
          |SET items = ?
          |WHERE id = ?
        """.stripMargin
      )

      updateCheckoutInfo <- session.prepare(
        """
          |UPDATE carts
          |SET status = ?, checkout_price = ?
          |WHERE id = ?
        """.stripMargin
      )
    } yield {
      insertCartStatement = insertCart
      updateCartItemsStatement = updateCartItems
      updateCartCheckoutStatement = updateCheckoutInfo
      Done
    }
  }

  /**
    * Method binding an event [[CartCreated]] to a [[insertCartStatement]]
    *
    * @param e event stream element which contains the [[CartCreated]] event
    * @return a future of list of bound statement.
    */
  private def cartCreated(e: EventStreamElement[CartCreated]): Future[List[BoundStatement]] = {
    Future.successful {
      val c = e.event
      List(insertCartStatement.bind(
        c.id,
        c.user,
        implicitly[Format[Set[CartItem]]].writes(c.items).toString,
        CartStatuses.IN_USE.toString
      ))
    }
  }

  /**
    * Method binding an event [[CartItemsUpdated]] to a [[updateCartItemsStatement]]
    *
    * @param e event stream element which contains the [[CartItemsUpdated]] event
    * @return a future of list of bound statement.
    */
  private def cartItemsUpdated(e: EventStreamElement[CartItemsUpdated]): Future[List[BoundStatement]] = {
    Future.successful {
      List(updateCartItemsStatement.bind(
        implicitly[Format[Set[CartItem]]].writes(e.event.items).toString,
        e.event.id
      ))
    }
  }

  /**
    * Method binding an event [[CartCheckedout]] to a [[updateCartCheckoutStatement]]
    *
    * @param e event stream element which contains the [[CartCheckedout]] event
    * @return a future of list of bound statement.
    */
  private def cartCheckedOut(e: EventStreamElement[CartCheckedout]): Future[List[BoundStatement]] = {
    Future.successful {
      val c = e.event
      List(updateCartCheckoutStatement.bind(
        CartStatuses.CHECKED_OUT.toString,
        e.event.price.toString,
        c.id
      ))
    }
  }

  /**
    * All [[CartEvent]] tags. This is part of Lagom's internal logic that allows ReadSide processors to be sharded over the
    * Akka cluster. Note that the number of shards is defined in [[CartEvent]].
    *
    * @return CartEvent all tags.
    */
  override def aggregateTags: Set[AggregateEventTag[CartEvent]] = CartEvent.Tag.allTags
}
